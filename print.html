<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Tonbo Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="start.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="usage/index.html"><strong aria-hidden="true">2.</strong> Usage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/tonbo.html"><strong aria-hidden="true">2.1.</strong> Tonbo</a></li><li class="chapter-item expanded "><a href="usage/python.html"><strong aria-hidden="true">2.2.</strong> Python Binding</a></li><li class="chapter-item expanded "><a href="usage/wasm.html"><strong aria-hidden="true">2.3.</strong> JavaScript Binding</a></li><li class="chapter-item expanded "><a href="usage/advance.html"><strong aria-hidden="true">2.4.</strong> Advance</a></li><li class="chapter-item expanded "><a href="usage/conf.html"><strong aria-hidden="true">2.5.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="usage/faq.html"><strong aria-hidden="true">2.6.</strong> FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/declare.html"><strong aria-hidden="true">3.1.</strong> Using Tonbo</a></li><li class="chapter-item expanded "><a href="examples/datafusion.html"><strong aria-hidden="true">3.2.</strong> Integrate with Datafusio</a></li><li class="chapter-item expanded "><a href="examples/wasm.html"><strong aria-hidden="true">3.3.</strong> Using under Wasm</a></li></ol></li><li class="chapter-item expanded "><a href="contribution/index.html"><strong aria-hidden="true">4.</strong> Contribution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contribution/build.html"><strong aria-hidden="true">4.1.</strong> Building</a></li><li class="chapter-item expanded "><a href="contribution/testing.html"><strong aria-hidden="true">4.2.</strong> Testing</a></li></ol></li><li class="chapter-item expanded "><a href="tonbolite/index.html"><strong aria-hidden="true">5.</strong> TonboLite</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tonbolite/start.html"><strong aria-hidden="true">5.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="tonbolite/build.html"><strong aria-hidden="true">5.2.</strong> Building</a></li><li class="chapter-item expanded "><a href="tonbolite/usage.html"><strong aria-hidden="true">5.3.</strong> Usage</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Tonbo Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tonbo-io/tonbo" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-tonbo-user-guide"><a class="header" href="#the-tonbo-user-guide">The Tonbo user guide</a></h1>
<p>Welcome to the tonbo user guide! This book is about <a href="https://github.com/tonbo-io/tonbo">tonbo</a>. Tonbo is an embedded, persistent database offering fast KV-like methods for conveniently writing and scanning type-safe structured data. Tonbo can be used to build data-intensive applications, including other types of databases.</p>
<p>The rough order of material in this user guide is as follows:</p>
<ol>
<li>Getting started</li>
<li>Examples on using tonbo</li>
<li>How to make contributions to Tonbo</li>
</ol>
<p>If you want to learn the design of tonbo, you can see this <a href="https://tonbo.io/blog/introducing-tonbo">blog</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="prerequisite"><a class="header" href="#prerequisite">Prerequisite</a></h3>
<p>To get started using tonbo you should make sure you have <a href="https://www.rust-lang.org/tools/install">Rust</a> installed on your system. If you haven't alreadly done yet, try following the instructions <a href="https://www.rust-lang.org/tools/install">here</a>.</p>
<h3 id="installation-1"><a class="header" href="#installation-1">Installation</a></h3>
<p>To use local disk as storage backend, you should import <a href="https://github.com/tokio-rs/tokio">tokio</a> crate and enable &quot;tokio&quot; feature (enabled by default)</p>
<pre><code class="language-toml">tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
tonbo = { git = &quot;https://github.com/tonbo-io/tonbo&quot; }
</code></pre>
<p>If you want to use tonbo in browser(use OPFS as storage backend), you should disable &quot;tokio&quot; feature and enable &quot;wasm&quot; feature. If you want to use S3 as backend, you also should enable &quot;wasm-http&quot; feature.</p>
<pre><code class="language-toml">tonbo = { git = &quot;https://github.com/tonbo-io/tonbo&quot;, default-features = false, features = [
    &quot;wasm&quot;,
    &quot;wasm-http&quot;,
] }
</code></pre>
<h2 id="using-tonbo"><a class="header" href="#using-tonbo">Using Tonbo</a></h2>
<h3 id="defining-schema"><a class="header" href="#defining-schema">Defining Schema</a></h3>
<p>Tonbo provides ORM-like macro for ease of use, you can use <code>Record</code> macro to define schema of column family. Tonbo will generate all relevant code for you at compile time.</p>
<pre><code class="language-rust">use tonbo::Record;

#[derive(Record, Debug)]
pub struct User {
    #[record(primary_key)]
    name: String,
    email: Option&lt;String&gt;,
    age: u8,
}</code></pre>
<ul>
<li><code>Record</code>: Declare this struct as a Tonbo Schema</li>
<li><code>#[record(primary_key)]</code>: Declare this key as primary key. Compound primary key is not supported now.</li>
<li><code>Option</code> type represents this field can be null, otherwise it can not be null.</li>
</ul>
<p>Now, Tonbo support these types:</p>
<ul>
<li>Number type: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code></li>
<li>Boolean type: <code>bool</code></li>
<li>String type: <code>String</code></li>
<li>Bytes: <code>bytes::Bytes</code></li>
</ul>
<h3 id="creating-database"><a class="header" href="#creating-database">Creating database</a></h3>
<p>After define you schema, you can create <code>DB</code> with a customized <code>DbOption</code></p>
<pre><code class="language-rust">use std::fs;
use fusio::path::Path;
use tonbo::{executor::tokio::TokioExecutor, DbOption, DB};

#[tokio::main]
async fn main() {
    // make sure the path exists
    fs::create_dir_all(&quot;./db_path/users&quot;).unwrap();

    let options = DbOption::new(
        Path::from_filesystem_path(&quot;./db_path/users&quot;).unwrap(),
        &amp;UserSchema,
    );
    let db = DB::&lt;User, TokioExecutor&gt;::new(options, TokioExecutor::current(), UserSchema)
        .await
        .unwrap();
}</code></pre>
<p><code>UserSchema</code> is a struct that tonbo generates for you in the compile time, so you do not need to import it.  One thing you need to pay attention to is: you should <strong>make sure the path exists</strong> before creating <code>DBOption</code>.</p>
<blockquote>
<p><strong>Note:</strong> If you use tonbo in WASM, you should use <code>Path::from_opfs_path</code> rather than <code>Path::from_filesystem_path</code>.</p>
</blockquote>
<h3 id="operations-on-database"><a class="header" href="#operations-on-database">Operations on Database</a></h3>
<p>After create <code>DB</code>, you can execute <code>insert</code>, <code>remove</code>, <code>get</code> and other operations now. But remember that you will get a <strong><code>UserRef</code> instance</strong> rather than the <code>User</code>, if you get record from tonbo. This is a struct that tonbo generates for you in the compile time. It may look like:</p>
<pre><code class="language-rust">#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct UserRef&lt;'r&gt; {
    pub name: &amp;'r str,
    pub email: Option&lt;&amp;'r str&gt;,
    pub age: Option&lt;u8&gt;,
}</code></pre>
<p>Then, you can start using tonbo like this:</p>
<pre><code class="language-rust">db.insert(User { /* ... */ }).await.unwrap();

let age = db.get(&amp;&quot;Alice&quot;.into(),
    |entry| {
        // entry.get() will get a `UserRef`
        let user = entry.get();
        println!(&quot;{:#?}&quot;, user);
        user.age
    })
    .await
    .unwrap();

db.remove(&quot;Alice&quot;.into()).await.unwrap();</code></pre>
<h4 id="using-transaction"><a class="header" href="#using-transaction">Using transaction</a></h4>
<p>Tonbo supports transaction. You can also push down filter, limit and projection operators in query.</p>
<pre><code class="language-rust">// create transaction
let txn = db.transaction().await;

let name = &quot;Alice&quot;.into();

txn.insert(User { /* ... */ });
let user = txn.get(&amp;name, Projection::All).await.unwrap();

let upper = &quot;Blob&quot;.into();
// range scan of user
let mut scan = txn
    .scan((Bound::Included(&amp;name), Bound::Excluded(&amp;upper)))
    .take()
    .await
    .unwrap();

while let Some(entry) = scan.next().await.transpose().unwrap() {
    let data = entry.value(); // type of UserRef
    // ......
}</code></pre>
<h3 id="persistence"><a class="header" href="#persistence">Persistence</a></h3>
<p>As Tonbo uses LSM(Log-Structured-Merge Tree) as the underlying data structure, some data are in the memory(mem). If you want to persist these data, you can use the <code>flush</code> method.</p>
<p>If WAL is enabled, the data will be persisted to disk automatically. But as tonbo has buffer for WAL by default, you need to call <code>flush_wal</code> method if you want to ensure that all the data will be recovered. If you don not want to use buffer for WAL, you can disable it by setting <code>wal_buffer_size</code> to 0.</p>
<pre><code class="language-rust">let options = DbOption::new(
    Path::from_filesystem_path(&quot;./db_path/users&quot;).unwrap(),
    &amp;UserSchema,
).wal_buffer_size(0);</code></pre>
<p>If you don't want to use WAL, you can disable it by setting the <code>DbOption::disable_wal</code>. But please ensure that losing data is acceptable for you.</p>
<pre><code class="language-rust">let options = DbOption::new(
    Path::from_filesystem_path(&quot;./db_path/users&quot;).unwrap(),
    &amp;UserSchema,
).disable_wal(true);</code></pre>
<blockquote>
<p><strong>Note</strong>: If you disable WAL, there is nothing to do with <code>flush_wal</code>. You need to call <code>flush</code> method to persist the memory data.</p>
<p>If you enable WAL and set <code>wal_buffer_size</code> to 0, you do not need to call <code>flush_wal</code> method, since WAL will be flushed to disk before writing.</p>
</blockquote>
<h3 id="using-in-s3"><a class="header" href="#using-in-s3">Using in S3</a></h3>
<p>If you want to use Tonbo in S3, you can configure <code>DbOption</code> to specify which part of the data to store in S3 and which part to store in local disk. Here is an example:</p>
<pre><code class="language-rust">let s3_option = FsOptions::S3 {
    bucket: &quot;wasm-data&quot;.to_string(),
    credential: Some(AwsCredential {
        key_id: &quot;key_id&quot;.to_string(),
        secret_key: &quot;secret_key&quot;.to_string(),
        token: None,
    }),
    endpoint: None,
    sign_payload: None,
    checksum: None,
    region: Some(&quot;region&quot;.to_string()),
};
let options = DbOption::new(
    Path::from_filesystem_path(&quot;./db_path/users&quot;).unwrap(),
    &amp;UserSchema,
).level_path(2, &quot;l2&quot;, s3_option.clone())
).level_path(3, &quot;l3&quot;, s3_option);</code></pre>
<p>In this example, the data of level 2 and level 3 will be stored in S3 and the rest of the data will be stored in local disk.</p>
<p>For more configuration options, please refer to the <a href="./usage/conf.html">Configuration</a> section.</p>
<h2 id="what-next"><a class="header" href="#what-next">What next?</a></h2>
<ul>
<li>To learn more about tonbo in Rust or in WASM, you can refer to <a href="./usage/tonbo.html">Tonbo API</a></li>
<li>To use tonbo in python, you can refer to <a href="./usage/python.html">Python API</a></li>
<li>To learn more about tonbo in brower, you can refer to <a href="./usage/wasm.html">WASM API</a></li>
<li>To learn more configuration about tonbo, you can refer to <a href="./usage/conf.html">Configuration</a></li>
<li>There are some data structures for runtime schema, you can use them to <a href="./usage/advance.html">expole tonbo</a>. You can also refer to our <a href="https://github.com/tonbo-io/tonbo/tree/main/bindings/python">python</a>, <a href="https://github.com/tonbo-io/tonbo/tree/main/bindings/js">wasm</a> bindings and <a href="https://github.com/tonbo-io/tonbolite">Tonbolite(a SQLite extension)</a></li>
<li>To learn more about tonbo by examples, you can refer to <a href="https://github.com/tonbo-io/tonbo/tree/main/examples">examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="tonbo-api"><a class="header" href="#tonbo-api">Tonbo API</a></h1>
<!-- toc -->
<h2 id="schema"><a class="header" href="#schema">Schema</a></h2>
<p>Tonbo provides ORM-like macro for ease of use, you can use <code>Record</code> macro to define schema of column family. Tonbo will generate all relevant code for you at compile time. For example, if you have a struct below</p>
<pre><code class="language-rust">use tonbo::Record;

#[derive(Record, Debug)]
pub struct User {
    #[record(primary_key)]
    name: String,
    email: Option&lt;String&gt;,
    age: u8,
}</code></pre>
<p>tonbo will generate a struct <code>UserSchema</code> where you can get schema from. Other than <code>UserSchema</code>, tonbo will also generate a <code>UserRef</code> struct. You should notice that the records you get from tonbo are <code>UserRef</code> and all fields except primary key are <code>Option</code>.</p>
<pre><code class="language-rust">#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct UserRef&lt;'r&gt; {
    pub name: &amp;'r str,
    pub email: Option&lt;&amp;'r str&gt;,
    pub age: Option&lt;u8&gt;,
}</code></pre>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<h3 id="create-database"><a class="header" href="#create-database">Create Database</a></h3>
<p>You can use <code>DB::new(DbOption, Schema)</code> to create a database. <code>DbOption</code> is the configuration options for the database and <code>Schema</code> is the <code>xxxSchema</code> that tonbo generated.</p>
<blockquote>
<p><strong>Note:</strong> If you use tonbo in WASM, you should use <code>Path::from_opfs_path</code> rather than <code>Path::from_filesystem_path</code>.</p>
</blockquote>
<pre><code class="language-rust">use std::fs;
use fusio::path::Path;
use tonbo::{executor::tokio::TokioExecutor, DbOption, DB};

#[tokio::main]
async fn main() {
    // make sure the path exists
    fs::create_dir_all(&quot;./db_path/users&quot;).unwrap();

    let options = DbOption::new(
        Path::from_filesystem_path(&quot;./db_path/users&quot;).unwrap(),
        &amp;UserSchema,
    );
    let db = DB::&lt;User, TokioExecutor&gt;::new(options, TokioExecutor::current(), UserSchema)
        .await
        .unwrap();
}</code></pre>
<h4 id="dboption"><a class="header" href="#dboption">DbOption</a></h4>
<p><code>DbOption</code> is a struct that contains configuration options for the database. Here are some configuration options you can set:</p>
<pre><code class="language-rust">// Creates a new `DbOption` instance with the given path and schema.
// The path is the default path that the database will use.
async fn new(option: DbOption, executor: E, schema: R::Schema) -&gt; Result&lt;Self, DbError&lt;R&gt;&gt;;

// Sets the path of the database.
fn path(self, path: impl Into&lt;Path&gt;) -&gt; Self;

/// disable the write-ahead log. This may risk of data loss during downtime
pub fn disable_wal(self) -&gt; Self;

/// Maximum size of WAL buffer, default value is 4KB
/// If set to 0, the WAL buffer will be disabled.
pub fn wal_buffer_size(self, wal_buffer_size: usize) -&gt; Self;</code></pre>
<p>If you want to learn more about <code>DbOption</code>, you can refer to the <a href="usage/conf.html">Configuration section</a>.</p>
<blockquote>
<p><strong>Note:</strong> You should make sure the path exists before creating <code>DBOption</code>.</p>
</blockquote>
<h4 id="executor"><a class="header" href="#executor">Executor</a></h4>
<p>Tonbo provides an <code>Executor</code> trait that you can implement to execute asynchronous tasks. Tonbo has implemented <code>TokioExecutor</code>(for local disk) and <code>OpfsExecutor</code>(for WASM) for users. You can also customize yourself Executor, here is an example implementation of the <code>Executor</code> trait:</p>
<pre><code class="language-rust">pub struct TokioExecutor {
    runtime: tokio::runtime::Runtime,
}

impl Executor for TokioExecutor {
    fn spawn&lt;F&gt;(&amp;self, future: F)
    where
        F: Future&lt;Output = ()&gt; + MaybeSend + 'static,
    {
        self.runtime.spawn(future);
    }
}</code></pre>
<h3 id="query"><a class="header" href="#query">Query</a></h3>
<p>You can use <code>get</code> method to get a record by key and you should pass a closure that takes a <code>TransactionEntry</code> instance and returns a <code>Option</code> type. You can use <code>TransactionEntry::get</code> to get a <code>UserRef</code> instance. This <code>UserRef</code> instance is a struct that tonbo generates for you. All fields except primary key are <code>Option</code> type, because you may not have set them when you create the record.</p>
<p>You can use <code>scan</code> method to scan all records that in the specified range. <code>scan</code> method will return a <code>Stream</code> instance and you can iterate all records by using this stream.</p>
<pre><code class="language-rust">/// get the record with `key` as the primary key and process it using closure `f`
let age = db.get(&amp;&quot;Alice&quot;.into(),
    |entry| {
        // entry.get() will get a `UserRef`
        let user = entry.get();
        println!(&quot;{:#?}&quot;, user);
        user.age
    })
    .await
    .unwrap();

let mut scan = db
    .scan((Bound::Included(&amp;name), Bound::Excluded(&amp;upper)))
    .await
    .unwrap();
while let Some(entry) = scan.next().await.transpose().unwrap() {
    let data = entry.value(); // type of UserRef
    // ......
}</code></pre>
<h3 id="insertremove"><a class="header" href="#insertremove">Insert/Remove</a></h3>
<p>You can use <code>db.insert(record)</code> or <code>db.insert_batch(records)</code> to insert new records into the database and use <code>db.remove(key)</code> to remove a record from the database. Here is an example of how to use transaction to update the state of database:</p>
<pre><code class="language-rust">
/// insert a single tonbo record
db.insert(User {
    name: &quot;Alice&quot;.into(),
    email: Some(&quot;alice@gmail.com&quot;.into()),
    age: 22,
    bytes: Bytes::from(vec![0, 1, 2]),
})
.await
.unwrap();

/// insert a sequence of data as a single batch
db.remove(&quot;Alice&quot;.into()).await.unwrap();</code></pre>
<h3 id="transaction"><a class="header" href="#transaction">Transaction</a></h3>
<p>Tonbo supports transactions when using a <code>Transaction</code>. You can use <code>db.transaction()</code> to create a transaction, and use <code>txn.commit()</code> to commit the transaction.</p>
<p>Note that Tonbo provides optimistic concurrency control to ensure data consistency which means that if a transaction conflicts with another transaction when committing, Tonbo will fail with a <code>CommitError</code>.</p>
<p>Here is an example of how to use transactions:</p>
<pre><code class="language-rust">// create transaction
let txn = db.transaction().await;

let name = &quot;Alice&quot;.into();

txn.insert(User { /* ... */ });
let _user = txn.get(&amp;name, Projection::Parts(vec![&quot;email&quot;, &quot;bytes&quot;])).await.unwrap();

let upper = &quot;Blob&quot;.into();
// range scan of user
let mut scan = txn
    .scan((Bound::Included(&amp;name), Bound::Excluded(&amp;upper)))
    // tonbo supports pushing down projection
    .projection(&amp;[&quot;email&quot;, &quot;bytes&quot;])
    // push down limitation
    .limit(1)
    .take()
    .await
    .unwrap();

while let Some(entry) = scan.next().await.transpose().unwrap() {
    let data = entry.value(); // type of UserRef
    // ......
}</code></pre>
<h4 id="query-1"><a class="header" href="#query-1">Query</a></h4>
<p>Transactions support easily reading the state of keys that are currently batched in a given transaction but not yet committed.</p>
<p>You can use <code>get</code> method to get a record by key, and <code>get</code> method will return a <code>UserRef</code> instance. This <code>UserRef</code> instance is a struct that tonbo generates for you in the compile time. All fields except primary key are <code>Option</code> type, because you may not have set them when you create the record. You can also pass a <code>Projection</code> to specify which fields you want to get. <code>Projection::All</code> will get all fields, <code>Projection::Parts(Vec&lt;&amp;str&gt;)</code> will get only primary key, <code>email</code> and <code>bytes</code> fields(other fields will be <code>None</code>).</p>
<p>You can use <code>scan</code> method to scan all records that in the specified range. <code>scan</code> method will return a <code>Scan</code> instance. You can use <code>take</code> method to get a <code>Stream</code> instance and iterate all records that satisfied. Tonbo also supports pushing down filters and projections. You can use <code>Scan::projection(vec![&quot;id&quot;, &quot;email&quot;])</code> to specify which fields you want to get and use <code>Scan::limit(10)</code> to limit the number of records you want to get.</p>
<pre><code class="language-rust">let txn = db.transaction().await;

let _user = txn.get(&amp;name, Projection::Parts(vec![&quot;email&quot;])).await.unwrap();

let mut scan_stream = txn
    .scan((Bound::Included(&amp;name), Bound::Excluded(&amp;upper)))
    // tonbo supports pushing down projection
    .projection(&amp;[&quot;email&quot;, &quot;bytes&quot;])
    // push down limitation
    .limit(10)
    .take()
    .await
    .unwrap();
while let Some(entry) = scan_stream.next().await.transpose().unwrap() {
    let data = entry.value(); // type of UserRef
    // ......
}</code></pre>
<h4 id="insertremove-1"><a class="header" href="#insertremove-1">Insert/Remove</a></h4>
<p>You can use <code>txn.insert(record)</code> to insert a new record into the database and use <code>txn.remove(key)</code> to remove a record from the database. Tonbo will use a B-Tree to store all data that you modified(insert/remove). All your modifications will be committed to the database when only you call <code>txn.commit()</code> successfully. If conflict happens, Tonbo will return an error and all your modifications will be rollback.</p>
<p>Here is an example of how to use transaction to update the state of database:</p>
<pre><code class="language-rust">
let mut txn = db.transaction().await;
txn.insert(User {
    id: 10,
    name: &quot;John&quot;.to_string(),
    email: Some(&quot;john@example.com&quot;.to_string()),
});
txn.remove(&quot;Alice&quot;.into());
txn.commit().await.unwrap();</code></pre>
<p>After create <code>DB</code>, you can execute <code>insert</code>, <code>remove</code>, <code>get</code> and other operations now. But remember that you will get a <strong><code>UserRef</code> instance</strong> rather than the <code>User</code>, if you get record from tonbo. This is a struct that tonbo generates for you in the compile time. It may look like:</p>
<h2 id="using-s3-backends"><a class="header" href="#using-s3-backends">Using S3 backends</a></h2>
<p>Tonbo supports various storage backends, such as OPFS, S3, and maybe more in the future. Tonbo wiil use local storage by default. If you want to use S3 storage for specific level, you can use <code>DbOption::level_path(FsOptions::S3)</code> so that all files in that level will be pushed to S3.</p>
<pre><code class="language-rust">use tonbo::option::{ AwsCredential, FsOptions, Path };
use tonbo::{executor::tokio::TokioExecutor, DbOption, DB};

#[tokio::main]
async fn main() {
    let fs_option = FsOptions::S3 {
        bucket: &quot;wasm-data&quot;.to_string(),
        credential: Some(AwsCredential {
            key_id: &quot;key_id&quot;.to_string(),
            secret_key: &quot;secret_key&quot;.to_string(),
            token: None,
        }),
        endpoint: None,
        sign_payload: None,
        checksum: None,
        region: Some(&quot;region&quot;.to_string()),
    };

    let options = DbOption::new(Path::from_filesystem_path(&quot;s3_path&quot;).unwrap(), &amp;UserSchema)
        .level_path(2, &quot;l2&quot;, fs_option);

    let db = DB::&lt;User, TokioExecutor&gt;::new(options, TokioExecutor::current(), UserSchema)
        .await
        .unwrap();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="explore-tonbo"><a class="header" href="#explore-tonbo">Explore Tonbo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<!-- toc -->
<p>Tonbo provides a configuration struct <code>DbOption</code> for setting up the database. This section will introduce the configuration options available in Tonbo.</p>
<h2 id="path-configuration"><a class="header" href="#path-configuration">Path Configuration</a></h2>
<p>Tonbo will use local disk as the default storage option(For local is the tokio file, for wasm is the OPFS). If you want to change the default storage backends  <code>DbOption::base_path</code>.</p>
<pre><code class="language-rust">pub fn base_fs(mut self, base_fs: FsOptions) -&gt; DbOption;</code></pre>
<p><code>FsOptions</code> is the configuration options for the file system. Tonbo provides two kinds of file system options: <code>FsOptions::Local</code> and <code>FsOptions::S3</code>.</p>
<ul>
<li><code>FsOptions::Local</code>: This is required the feature <code>tokio</code>/<code>wasm</code> to be enabled.</li>
<li><code>FsOptions::S3{...}</code>: This is required the feature <code>aws</code> and <code>tokio-http</code>/<code>wasm-http</code> to be enabled. You can use this <code>FsOptions</code> to configure the S3 storage.</li>
</ul>
<pre><code class="language-rust">pub enum FsOptions {
    #[cfg(any(feature = &quot;tokio&quot;, feature = &quot;wasm&quot;))]
    Local,
    #[cfg(feature = &quot;aws&quot;)]
    S3 {
        bucket: String,
        credential: Option&lt;AwsCredential&gt;,
        endpoint: Option&lt;String&gt;,
        region: Option&lt;String&gt;,
        sign_payload: Option&lt;bool&gt;,
        checksum: Option&lt;bool&gt;,
    },
}

#[derive(Debug, Clone)]
pub struct AwsCredential {
    /// AWS_ACCESS_KEY_ID
    pub key_id: String,
    /// AWS_SECRET_ACCESS_KEY
    pub secret_key: String,
    /// AWS_SESSION_TOKEN
    pub token: Option&lt;String&gt;,
}</code></pre>
<ul>
<li><code>bucket</code>: The S3 bucket</li>
<li><code>credential</code>: The credential configuration for S3
<ul>
<li><code>key_id</code>: The S3 access key</li>
<li><code>secret_key</code>: The S3 secret access key</li>
<li><code>token</code>: is the security token for the aws S3</li>
</ul>
</li>
<li><code>endpoint</code>: The S3 endpoint</li>
<li><code>region</code>: The S3 region</li>
<li><code>sign_payload</code>: Whether to sign payload for the aws S3</li>
<li><code>checksum</code>: Whether to enable checksum for the aws S3</li>
</ul>
<p>If you want to set specific storage options for SSTables, you can use <code>DbOption::level_path</code>. This method allows you to specify the storage options for each level of SSTables. If you don't specify the storage options for a level, Tonbo will use the default storage options(that is base fs).</p>
<pre><code class="language-rust">pub fn level_path(
    mut self,
    level: usize,
    path: Path,
    fs_options: FsOptions,
) -&gt; Result&lt;DbOption, ExceedsMaxLevel&gt;;</code></pre>
<h2 id="manifest-configuration"><a class="header" href="#manifest-configuration">Manifest Configuration</a></h2>
<p>Manifest is used to store the metadata of the database. Whenever the compaction is triggered, the manifest will be updated accordingly. But when time goes by, the manifest file will become large, which will increase the time of recovery. Tonbo will rewrite the manifest file if metadata too much, you can use <code>DbOption::version_log_snapshot_threshold</code> to configure</p>
<pre><code class="language-rust">pub fn version_log_snapshot_threshold(self, version_log_snapshot_threshold: u32) -&gt; DbOption;</code></pre>
<h2 id="wal-configuration"><a class="header" href="#wal-configuration">WAL Configuration</a></h2>
<p>Tonbo use WAL(Write-ahead log) to ensure data durability and consistency. It is a mechanism that ensures that data is written to the log before being written to the database. This helps to prevent data loss in case of a system failure.</p>
<p>Tonbo also provides a buffer to improve performance. If you want to flush wal buffer, you can call <code>DbOption::flush_wal</code>. The default buffer size is 4KB. But If you don't want to use wal buffer, you can set the buffer to 0.</p>
<pre><code class="language-rust">pub fn wal_buffer_size(self, wal_buffer_size: usize) -&gt; DbOption;</code></pre>
<p>If you don't want to use WAL, you can disable it by setting the <code>DbOption::disable_wal</code>. But please ensure that losing data is acceptable for you.</p>
<pre><code class="language-rust">pub fn disable_wal(self) -&gt; DbOption;</code></pre>
<h2 id="compaction-configuration"><a class="header" href="#compaction-configuration">Compaction Configuration</a></h2>
<p>When memtable reaches the maximum size, we will turn it into a immutable which is read only memtable. But when the number of immutable table reaches the maximum size, we will compact them to SSTables. You can set the <code>DbOption::immutable_chunk_num</code> to control the number of files for compaction.</p>
<pre><code class="language-rust">/// len threshold of `immutables` when minor compaction is triggered
pub fn immutable_chunk_num(self, immutable_chunk_num: usize) -&gt; DbOption;</code></pre>
<p>When the number of files in level L exceeds its limit, we also compact them in a background thread. Tonbo use the <code>major_threshold_with_sst_size</code> and <code>level_sst_magnification</code> to determine when to trigger major compaction. The calculation is as follows:</p>
<p>\[ major\_threshold\_with\_sst\_size * level\_sst\_magnification^{level} \]</p>
<p><code>major_threshold_with_sst_size</code> is default to 4 and <code>level_sst_magnification</code> is default to 10, which means that the default trigger threshold for level1 is 40 files and 400 for level2.</p>
<p>You can adjust the <code>major_threshold_with_sst_size</code> and <code>level_sst_magnification</code> to control the compaction behavior.</p>
<pre><code class="language-rust">/// threshold for the number of `parquet` when major compaction is triggered
pub fn major_threshold_with_sst_size(self, major_threshold_with_sst_size: usize) -&gt; DbOption

/// magnification that triggers major compaction between different levels
pub fn level_sst_magnification(self, level_sst_magnification: usize) -&gt; DbOption;</code></pre>
<p>You can also change the default SSTable size by setting the <code>DbOption::max_sst_file_size</code>, but we found that the default size is good enough for most use cases.</p>
<pre><code class="language-rust">/// Maximum size of each parquet
pub fn max_sst_file_size(self, max_sst_file_size: usize) -&gt; DbOption</code></pre>
<h2 id="sstable-configuration"><a class="header" href="#sstable-configuration">SSTable Configuration</a></h2>
<p>Tonbo use <a href="https://github.com/apache/parquet-rs">parquet</a> to store data which means you can set <code>WriterProperties</code> for parquet file. You can use <code>DbOption::write_parquet_option</code> to set specific settings for Parquet.</p>
<pre><code class="language-rust">/// specific settings for Parquet
pub fn write_parquet_option(self, write_parquet_properties: WriterProperties) -&gt; DbOption</code></pre>
<p>Here is an example of how to use <code>DbOption::write_parquet_option</code>:</p>
<pre><code class="language-rust">let db_option = DbOption::default().write_parquet_option(
    WriterProperties::builder()
        .set_compression(Compression::LZ4)
        .set_statistics_enabled(EnabledStatistics::Chunk)
        .set_bloom_filter_enabled(true)
        .build(),
);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="failed-to-run-custom-build-command-for-ring-in-macos"><a class="header" href="#failed-to-run-custom-build-command-for-ring-in-macos">Failed to run custom build command for <code>ring</code> in macOS</a></h2>
<p>Apple Clang is a fork of Clang that is specialized to Apple's wishes. It doesn't support wasm32-unknown-unknown. You need to download and use llvm.org Clang instead. You can refer to this <a href="https://github.com/briansmith/ring/issues/1824">issue</a> for more information.</p>
<pre><code class="language-bash">brew install llvm
echo 'export PATH=&quot;/opt/homebrew/opt/llvm/bin:$PATH&quot;' &gt;&gt; ~/.zshrc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-of-using-tonbo"><a class="header" href="#examples-of-using-tonbo">Examples of using Tonbo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-tonbo-1"><a class="header" href="#using-tonbo-1">Using Tonbo</a></h1>
<p>define your schema</p>
<pre><code class="language-rust">use tonbo::Record;

/// Use macro to define schema of column family just like ORM
/// It provides type-safe read &amp; write API
#[derive(Record, Debug)]
pub struct User {
    #[record(primary_key)]
    name: String,
    email: Option&lt;String&gt;,
    age: u8,
    bytes: Bytes,
}</code></pre>
<pre><code class="language-rust">use std::ops::Bound;

use bytes::Bytes;
use fusio::path::Path;
use futures_util::stream::StreamExt;
use tokio::fs;
use tonbo::{executor::tokio::TokioExecutor, DbOption, Projection, Record, DB};


#[tokio::main]
async fn main() {
    // make sure the path exists
    let _ = fs::create_dir_all(&quot;./db_path/users&quot;).await;

    let options = DbOption::new(
        Path::from_filesystem_path(&quot;./db_path/users&quot;).unwrap(),
        &amp;UserSchema,
    );
    // pluggable async runtime and I/O
    let db = DB::new(options, TokioExecutor::current(), UserSchema)
        .await
        .unwrap();

    // insert with owned value
    db.insert(User {
        name: &quot;Alice&quot;.into(),
        email: Some(&quot;alice@gmail.com&quot;.into()),
        age: 22,
        bytes: Bytes::from(vec![0, 1, 2]),
    })
    .await
    .unwrap();

    {
        // tonbo supports transaction
        let txn = db.transaction().await;

        // get from primary key
        let name = &quot;Alice&quot;.into();

        // get the zero-copy reference of record without any allocations.
        let user = txn
            .get(
                &amp;name,
                // tonbo supports pushing down projection
                Projection::All,
            )
            .await
            .unwrap();
        assert!(user.is_some());
        assert_eq!(user.unwrap().get().age, Some(22));

        {
            let upper = &quot;Blob&quot;.into();
            // range scan of user
            let mut scan = txn
                .scan((Bound::Included(&amp;name), Bound::Excluded(&amp;upper)))
                // tonbo supports pushing down projection
                .projection(vec![1, 3])
                // push down limitation
                .limit(1)
                .take()
                .await
                .unwrap();
            while let Some(entry) = scan.next().await.transpose().unwrap() {
                assert_eq!(
                    entry.value(),
                    Some(UserRef {
                        name: &quot;Alice&quot;,
                        email: Some(&quot;alice@gmail.com&quot;),
                        age: None,
                        bytes: Some(&amp;[0, 1, 2]),
                    })
                );
            }
        }

        // commit transaction
        txn.commit().await.unwrap();
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrate-with-datafusion"><a class="header" href="#integrate-with-datafusion">Integrate with Datafusion</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-under-wasm"><a class="header" href="#using-under-wasm">Using under Wasm</a></h1>
<p>This is the Wasm example of tonbo showing how to use tonbo under Wasm.</p>
<h2 id="cargotoml"><a class="header" href="#cargotoml"><code>Cargo.toml</code></a></h2>
<p>Since only limited features of tokio can be used in wasm, we need to disable tokio and use <code>wasm</code> feature in tonbo.</p>
<pre><code class="language-toml">fusio = { git = &quot;https://github.com/tonbo-io/fusio.git&quot;, rev = &quot;216eb446fb0a0c6e5e85bfac51a6f6ed8e5ed606&quot;, package = &quot;fusio&quot;, version = &quot;0.3.3&quot;, features = [
  &quot;dyn&quot;,
  &quot;fs&quot;,
] }
tonbo = { git = &quot;https://github.com/tonbo-io/tonbo&quot;, default-features = false, features = [&quot;wasm&quot;] }
</code></pre>
<h2 id="create-db"><a class="header" href="#create-db">Create DB</a></h2>
<p>Tonbo provide <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_API/Origin_private_file_system">OPFS(origin private file system)</a> as storage backend, but the path is a little different. You should use <code>Path::from_opfs_path</code> or <code>Path::parse</code> rather than <code>Path::from_filesystem_path</code> and it is not permitted to use paths that temporarily step outside the sandbox with something like <code>../foo</code> or <code>./bar</code>.</p>
<pre><code class="language-rust">use fusio::path::Path;
use tonbo::{executor::opfs::OpfsExecutor, DbOption, DB};

async fn main() {

    let options = DbOption::new(
        Path::from_opfs_path(&quot;db_path/users&quot;).unwrap(),
        &amp;UserSchema,
    );
    let db = DB::&lt;User, OpfsExecutor&gt;::new(options, OpfsExecutor::new(), UserSchema)
        .await
        .unwrap();
}</code></pre>
<h2 id="operations-on-db"><a class="header" href="#operations-on-db">Operations on DB</a></h2>
<p>After create <code>DB</code> instance, you can operate it as usual</p>
<pre><code class="language-rust">let txn = db.transaction().await;

// get from primary key
let name = &quot;Alice&quot;.into();

let user = txn.get(&amp;name, Projection::All).await.unwrap();

let upper = &quot;Blob&quot;.into();
// range scan of user
let mut scan = txn
    .scan((Bound::Included(&amp;name), Bound::Excluded(&amp;upper)))
    // tonbo supports pushing down projection
    .projection(vec![1])
    // push down limitation
    .limit(1)
    .take()
    .await
    .unwrap();

while let Some(entry) = scan.next().await.transpose().unwrap() {
    assert_eq!(
        entry.value(),
        Some(UserRef {
            name: &quot;Alice&quot;,
            email: Some(&quot;alice@gmail.com&quot;),
            age: None,
        })
    );
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="building-tonbo"><a class="header" href="#building-tonbo">Building Tonbo</a></h1>
<p>To get started using tonbo you should make sure you have <a href="https://www.rust-lang.org/tools/install">Rust</a> installed on your system. If you haven't alreadly done yet, try following the instructions <a href="https://www.rust-lang.org/tools/install">here</a>.</p>
<h2 id="building-tonbo-for-rust"><a class="header" href="#building-tonbo-for-rust">Building Tonbo for Rust</a></h2>
<p>To use local disk as storage backend, you should import <a href="https://github.com/tokio-rs/tokio">tokio</a> crate and enable &quot;tokio&quot; feature (enabled by default)</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>If you want to build tonbo under wasm, you should add wasm32-unknown-unknown target first.</p>
<pre><code class="language-bash"># add wasm32-unknown-unknown target
rustup target add wasm32-unknown-unknown
# build under wasm
cargo build --target wasm32-unknown-unknown --no-default-features --features wasm
</code></pre>
<h2 id="building-tonbo-for-python"><a class="header" href="#building-tonbo-for-python">Building Tonbo for Python</a></h2>
<p>We use the <a href="https://github.com/PyO3/pyo3">pyo3</a> to generate a native Python module and use <a href="https://github.com/PyO3/maturin">maturin</a> to build Rust-based Python packages.</p>
<p>First, follow the commands below to build a new Python virtualenv, and install maturin into the virtualenv using Python's package manager, pip:</p>
<pre><code class="language-bash"># setup virtualenv
python -m venv .env
# activate venv
source .env/bin/activate

# install maturin
pip install maturin
# build bindings
maturin develop
</code></pre>
<p>Whenever Rust code changes run:</p>
<pre><code class="language-bash">maturin develop
</code></pre>
<h2 id="building-tonbo-for-javascript"><a class="header" href="#building-tonbo-for-javascript">Building Tonbo for JavaScript</a></h2>
<p>To build tonbo for JavaScript, you should install <a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a>. If you haven't already done so, try following the instructions <a href="https://rustwasm.github.io/wasm-pack/installer/">here</a>.</p>
<pre><code class="language-bash"># add wasm32-unknown-unknown target
rustup target add wasm32-unknown-unknown
# build under wasm
wasm-pack build --target web
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<h2 id="testing-tonbo-in-rust"><a class="header" href="#testing-tonbo-in-rust">Testing Tonbo in Rust</a></h2>
<h2 id="testing-tonbo-in-wasm"><a class="header" href="#testing-tonbo-in-wasm">Testing Tonbo in WASM</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tonbolite"><a class="header" href="#tonbolite">TonboLite</a></h1>
<p>TonboLite is a WASM compatible SQLite extension that allows users to create tables which supports analytical processing directly in SQLite. Its storage engine is powered by our open-source embedded key-value database, <a href="https://github.com/tonbo-io/tonbo">Tonbo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-tonbolite"><a class="header" href="#building-tonbolite">Building TonboLite</a></h1>
<h3 id="build-as-extension"><a class="header" href="#build-as-extension">Build as Extension</a></h3>
<p>To build TonboLite as an extension, you should enable loadable_extension features</p>
<pre><code class="language-sh">cargo build --release --features loadable_extension
</code></pre>
<p>Once building successfully, you will get a file named libsqlite_tonbo.dylib(<code>.dll</code> on windows, <code>.so</code> on most other unixes) in <em>target/release/</em></p>
<h3 id="build-on-rust"><a class="header" href="#build-on-rust">Build on Rust</a></h3>
<pre><code class="language-sh">cargo build
</code></pre>
<h3 id="build-on-wasm"><a class="header" href="#build-on-wasm">Build on Wasm</a></h3>
<p>To use TonboLite in wasm, it takes a few steps to build.</p>
<ol>
<li>Add wasm32-unknown-unknown target</li>
</ol>
<pre><code class="language-sh">rustup target add wasm32-unknown-unknown
</code></pre>
<ol start="2">
<li>Override toolchain with nightly</li>
</ol>
<pre><code class="language-sh">rustup override set nightly
</code></pre>
<ol start="3">
<li>Build with <a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a></li>
</ol>
<pre><code class="language-sh">wasm-pack build --target web --no-default-features --features wasm
</code></pre>
<p>Once you build successfully, you will get a <em>pkg</em> folder containing compiled js and wasm files. Copy it to your project and then you can start to use it.</p>
<pre><code class="language-js">const tonbo = await import(&quot;./pkg/sqlite_tonbo.js&quot;);
await tonbo.default();

// start to use TonboLite ...
</code></pre>
<div class="warning">
<p>TonboLite should be used in a <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts">secure context</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/crossOriginIsolated">cross-origin isolated</a>, since it uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a> to share memory. Please refer to <a href="https://web.dev/articles/coop-coep">this article</a> for a detailed explanation.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<!-- toc -->
<h2 id="using-as-extension"><a class="header" href="#using-as-extension">Using as Extension</a></h2>
<p>If you do not know how to build TonboLite, please refer to the <a href="tonbolite/./build.html">Building</a> section.</p>
<h3 id="loading-tonbolite-extension"><a class="header" href="#loading-tonbolite-extension">Loading TonboLite Extension</a></h3>
<p>Once building successfully, you will get a file named libsqlite_tonbo.dylib(.dll on windows, .so on most other unixes) in <em>target/release/</em>(or <em>target/debug/</em>).</p>
<p>SQLite provide <a href="https://www.sqlite.org/cli.html#loading_extensions"><code>.load</code></a> command to load a SQLite extension. So, you can load TonboLite extension by running the following command:</p>
<pre><code class="language-bash">.load target/release/libsqlite_tonbo
</code></pre>
<p>Or you can load TonboLite extension in Python or other languages.</p>
<pre><code class="language-py">import sqlite3

conn = sqlite3.connect(&quot;:memory&quot;)
conn.enable_load_extension(True)
# Load the tonbolite extension
conn.load_extension(&quot;target/release/libsqlite_tonbo.dylib&quot;)
con.enable_load_extension(False)

# ......
</code></pre>
<p>After loading TonboLite successfully, you can start to use it.</p>
<h3 id="create-table"><a class="header" href="#create-table">Create Table</a></h3>
<p>Unlike Normal <code>CREATE TABLE</code> statement, TonboLite use <a href="https://www.sqlite.org/vtab.html">SQLite Virtual Table</a> syntax to create a table:</p>
<pre><code class="language-sql">CREATE VIRTUAL TABLE temp.tonbo USING tonbo(
    create_sql = 'create table tonbo(id bigint primary key, name varchar, like int)',
    path = 'db_path/tonbo'
);
</code></pre>
<h3 id="selectinsertupdatedelete"><a class="header" href="#selectinsertupdatedelete">Select/Insert/Update/Delete</a></h3>
<p>you can execute SQL statements just like normal SQL in the SQLite. Here is an example:</p>
<pre><code class="language-sql">sqlite&gt; .load target/release/libsqlite_tonbo

sqlite&gt; CREATE VIRTUAL TABLE temp.tonbo USING tonbo(
    create_sql = 'create table tonbo(id bigint primary key, name varchar, like int)',
    path = 'db_path/tonbo'
);
sqlite&gt; insert into tonbo (id, name, like) values (0, 'tonbo', 100);
sqlite&gt; insert into tonbo (id, name, like) values (1, 'sqlite', 200);

sqlite&gt; select * from tonbo;
0|tonbo|100
1|sqlite|200

sqlite&gt; update tonbo set like = 123 where id = 0;

sqlite&gt; select * from tonbo;
0|tonbo|123
1|sqlite|200

sqlite&gt; delete from tonbo where id = 0;

sqlite&gt; select * from tonbo;
1|sqlite|200
</code></pre>
<h3 id="flush"><a class="header" href="#flush">Flush</a></h3>
<p>TonboLite use LSM tree to store data, and it use a WAL buffer size to improve performance, so you may need to flush data to disk manually. But SQLite don't provide flush interface, so we choose to implement it in the <a href="https://www.sqlite.org/pragma.html#pragma_quick_check"><code>pragma quick_check</code></a>.</p>
<pre><code class="language-sql">PRAGMA tonbo.quick_check;
</code></pre>
<h2 id="using-in-rust"><a class="header" href="#using-in-rust">Using in Rust</a></h2>
<p>To use TonboLite in your application, you can import TonboLite in the <em>Cargo.toml</em> file.</p>
<pre><code class="language-toml">tonbolite = { git = &quot;https://github.com/tonbo-io/tonbolite&quot; }
</code></pre>
<p>You can create use TonboLite just like in <a href="https://github.com/rusqlite/rusqlite">Rusqlite</a>, but you should create table using <a href="https://www.sqlite.org/vtab.html">SQLite Virtual Table</a> syntax:</p>
<pre><code class="language-rust">let _ = std::fs::create_dir_all(&quot;./db_path/test&quot;);

let db = rusqlite::Connection::open_in_memory()?;
crate::load_module(&amp;db)?;

db.execute_batch(
    &quot;CREATE VIRTUAL TABLE temp.tonbo USING tonbo(
            create_sql = 'create table tonbo(id bigint primary key, name varchar, like int)',
            path = 'db_path/test'
    );&quot;
).unwrap();

db.execute(
    &quot;INSERT INTO tonbo (id, name, like) VALUES (1, 'lol', 12)&quot;,
    [],
).unwrap();

let mut stmt = db.prepare(&quot;SELECT * FROM tonbo;&quot;)?;
let _rows = stmt.query([])?;</code></pre>
<p>for more usage, you can refer to <a href="https://docs.rs/rusqlite">Rusqlite</a>.</p>
<p>One difference is that TonboLite extends <a href="https://www.sqlite.org/pragma.html#pragma_quick_check"><code>pragma quick_check</code></a> to flush WAL to disk. You can use it like this:</p>
<pre><code class="language-rust">db.pragma(None, &quot;quick_check&quot;, &quot;tonbo&quot;, |_r| -&gt; rusqlite::Result&lt;()&gt; {
    Ok(())
}).unwrap();</code></pre>
<h2 id="using-in-javascript"><a class="header" href="#using-in-javascript">Using in JavaScript</a></h2>
<p>To use TonboLite in wasm, can should enable <em>wasm</em> feature.</p>
<pre><code class="language-toml">tonbolite = { git = &quot;https://github.com/tonbo-io/tonbolite&quot;, default-features = false, features = [&quot;wasm&quot;] }
</code></pre>
<p>After building successfully, you will get a <em>pkg</em> folder containing compiled js and wasm files. Copy it to your project and then you can start to use it. If you don't know how to build TonboLite on wasm, you can refer to <a href="tonbolite/build.html#build-on-wasm">TonboLite</a>.</p>
<p>Here is an example of how to use TonboLite in JavaScript:</p>
<pre><code class="language-javascript">const tonbo = await import(&quot;./pkg/sqlite_tonbo.js&quot;);
await tonbo.default();

const db = new TonboLite('db_path/test');
await db.create(`CREATE VIRTUAL TABLE temp.tonbo USING tonbo(
  create_sql ='create table tonbo(id bigint primary key, name varchar, like int)',
  path = 'db_path/tonbo'
);`);

await db.insert('INSERT INTO tonbo (id, name, like) VALUES (1, \'lol\', 12)');
await conn.delete(&quot;DELETE FROM tonbo WHERE id = 4&quot;);
await conn.update(&quot;UPDATE tonbo SET name = 'tonbo' WHERE id = 6&quot;);

const rows = await db.select('SELECT * FROM tonbo limit 10;');
console.log(rows);

await db.flush();
</code></pre>
<div class="warning">
<p>TonboLite should be used in a <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts">secure context</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/crossOriginIsolated">cross-origin isolated</a>, since it uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a> to share memory. Please refer to <a href="https://web.dev/articles/coop-coep">this article</a> for a detailed explanation.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
